"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/game/CrashGame.ts":
/*!*******************************!*\
  !*** ./src/game/CrashGame.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrashGame: () => (/* binding */ CrashGame)\n/* harmony export */ });\nconst simpleHash = (str)=>{\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash // Convert to 32-bit integer\n        ;\n    }\n    return Math.abs(hash).toString(16);\n};\nclass CrashGame {\n    getInitialState() {\n        return {\n            phase: 'waiting',\n            multiplier: 1.00,\n            crashPoint: 1.00,\n            startTime: null,\n            elapsed: 0,\n            hash: '',\n            seed: '',\n            previousGames: []\n        };\n    }\n    // Provably fair crash point generation\n    generateNextCrashPoint() {\n        // For demo purposes - in production this would come from server\n        const serverSeed = Math.random().toString(36).substring(2);\n        const clientSeed = Math.random().toString(36).substring(2);\n        const combinedSeed = \"\".concat(serverSeed, \"-\").concat(clientSeed);\n        const hash = simpleHash(combinedSeed);\n        // Use the first 8 characters of hash for randomness\n        const seedInt = parseInt(hash.slice(0, 8), 16);\n        const max = 0xffffffff // 32-bit max\n        ;\n        // Generate crash point between 1 and 10 for demo\n        const rawPoint = seedInt % 900 / 100 + 1 // 1.00 to 10.00\n        ;\n        const crashPoint = Math.max(1.00, rawPoint * this.HOUSE_EDGE);\n        return {\n            value: crashPoint,\n            hash: hash,\n            seed: combinedSeed\n        };\n    }\n    calculateMultiplier(elapsed) {\n        // Exponential growth function\n        // 1.0696^t where t is seconds elapsed\n        return Math.pow(1.0696, elapsed / 1000);\n    }\n    startGame() {\n        var _this_callbacks_onStarting, _this_callbacks, _this_callbacks_onUpdate, _this_callbacks1;\n        if (this.state.phase !== 'waiting') return;\n        // Start countdown phase\n        this.state.phase = 'starting';\n        (_this_callbacks_onStarting = (_this_callbacks = this.callbacks).onStarting) === null || _this_callbacks_onStarting === void 0 ? void 0 : _this_callbacks_onStarting.call(_this_callbacks);\n        // 3 second countdown\n        setTimeout(()=>{\n            var _this_callbacks_onGameStart, _this_callbacks;\n            this.state.phase = 'in-progress';\n            this.state.startTime = Date.now();\n            this.lastUpdateTime = this.state.startTime;\n            (_this_callbacks_onGameStart = (_this_callbacks = this.callbacks).onGameStart) === null || _this_callbacks_onGameStart === void 0 ? void 0 : _this_callbacks_onGameStart.call(_this_callbacks);\n            this.update();\n        }, 3000);\n        (_this_callbacks_onUpdate = (_this_callbacks1 = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks1, this.state);\n    }\n    crash() {\n        var _this_callbacks_onCrash, _this_callbacks;\n        // Stop updates\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n        this.state.phase = 'crashed';\n        (_this_callbacks_onCrash = (_this_callbacks = this.callbacks).onCrash) === null || _this_callbacks_onCrash === void 0 ? void 0 : _this_callbacks_onCrash.call(_this_callbacks, this.state.crashPoint);\n        // Store game history\n        this.state.previousGames.unshift({\n            crashPoint: this.state.crashPoint,\n            hash: this.state.hash,\n            seed: this.state.seed\n        });\n        // Keep last 50 games\n        if (this.state.previousGames.length > 50) {\n            this.state.previousGames.pop();\n        }\n        // Generate next crash point\n        const nextCrash = this.generateNextCrashPoint();\n        // Reset for next round after delay\n        setTimeout(()=>{\n            var _this_callbacks_onUpdate, _this_callbacks;\n            this.state = {\n                ...this.getInitialState(),\n                crashPoint: nextCrash.value,\n                hash: nextCrash.hash,\n                seed: nextCrash.seed,\n                previousGames: this.state.previousGames\n            };\n            (_this_callbacks_onUpdate = (_this_callbacks = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks, this.state);\n        }, 2000);\n    }\n    verifyGameResult(hash, seed) {\n        const verificationHash = simpleHash(seed);\n        if (verificationHash !== hash) {\n            throw new Error('Invalid game result');\n        }\n        const seedInt = parseInt(hash.slice(0, 8), 16);\n        const max = 0xffffffff;\n        const rawPoint = seedInt % 900 / 100 + 1;\n        return Math.max(1.00, rawPoint * this.HOUSE_EDGE);\n    }\n    getGameStats() {\n        const games = this.state.previousGames;\n        return {\n            totalGames: games.length,\n            averageMultiplier: games.reduce((acc, game)=>acc + game.crashPoint, 0) / games.length,\n            maxMultiplier: Math.max(...games.map((game)=>game.crashPoint)),\n            minMultiplier: Math.min(...games.map((game)=>game.crashPoint)),\n            below2x: games.filter((game)=>game.crashPoint < 2).length,\n            above10x: games.filter((game)=>game.crashPoint > 10).length\n        };\n    }\n    subscribe(callbacks) {\n        this.callbacks = callbacks;\n    }\n    getState() {\n        return {\n            ...this.state\n        };\n    }\n    cleanup() {\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n        }\n    }\n    constructor(){\n        this.HOUSE_EDGE = 0.99 // 1% house edge\n        ;\n        this.GAME_UPDATE_RATE = 60 // Updates per second\n        ;\n        this.updateInterval = null;\n        this.lastUpdateTime = 0;\n        this.callbacks = {};\n        this.update = ()=>{\n            var _this_callbacks_onUpdate, _this_callbacks;\n            if (this.state.phase !== 'in-progress' || !this.state.startTime) return;\n            const now = Date.now();\n            const deltaTime = now - this.lastUpdateTime;\n            this.lastUpdateTime = now;\n            if (deltaTime < 1000 / this.GAME_UPDATE_RATE) return;\n            this.state.elapsed = now - this.state.startTime;\n            this.state.multiplier = this.calculateMultiplier(this.state.elapsed);\n            // Check for crash\n            if (this.state.multiplier >= this.state.crashPoint) {\n                this.crash();\n                return;\n            }\n            (_this_callbacks_onUpdate = (_this_callbacks = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks, this.state);\n            requestAnimationFrame(this.update);\n        };\n        this.state = this.getInitialState();\n        this.generateNextCrashPoint();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9nYW1lL0NyYXNoR2FtZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsYUFBYSxDQUFDQztJQUNsQixJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLElBQUlHLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxPQUFPSixJQUFJSyxVQUFVLENBQUNIO1FBQzVCRCxPQUFPLENBQUVBLFFBQVEsS0FBS0EsT0FBUUc7UUFDOUJILE9BQU9BLE9BQU9BLEtBQUssNEJBQTRCOztJQUNqRDtJQUNBLE9BQU9LLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTU8sUUFBUSxDQUFDO0FBQ2pDO0FBeUJPLE1BQU1DO0lBbUJIQyxrQkFBNkI7UUFDbkMsT0FBTztZQUNMQyxPQUFPO1lBQ1BDLFlBQVk7WUFDWkMsWUFBWTtZQUNaQyxXQUFXO1lBQ1hDLFNBQVM7WUFDVGQsTUFBTTtZQUNOZSxNQUFNO1lBQ05DLGVBQWUsRUFBRTtRQUNuQjtJQUNGO0lBRUEsdUNBQXVDO0lBQy9CQyx5QkFBcUM7UUFDM0MsZ0VBQWdFO1FBQ2hFLE1BQU1DLGFBQWFiLEtBQUtjLE1BQU0sR0FBR1osUUFBUSxDQUFDLElBQUlhLFNBQVMsQ0FBQztRQUN4RCxNQUFNQyxhQUFhaEIsS0FBS2MsTUFBTSxHQUFHWixRQUFRLENBQUMsSUFBSWEsU0FBUyxDQUFDO1FBQ3hELE1BQU1FLGVBQWUsR0FBaUJELE9BQWRILFlBQVcsS0FBYyxPQUFYRztRQUN0QyxNQUFNckIsT0FBT0YsV0FBV3dCO1FBRXhCLG9EQUFvRDtRQUNwRCxNQUFNQyxVQUFVQyxTQUFTeEIsS0FBS3lCLEtBQUssQ0FBQyxHQUFHLElBQUk7UUFDM0MsTUFBTUMsTUFBTSxXQUFXLGFBQWE7O1FBRXBDLGlEQUFpRDtRQUNqRCxNQUFNQyxXQUFXLFVBQVcsTUFBTyxNQUFNLEVBQUUsZ0JBQWdCOztRQUMzRCxNQUFNZixhQUFhUCxLQUFLcUIsR0FBRyxDQUFDLE1BQU1D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dkIsS0FBSyxLQUFLLGlCQUFpQixDQUFDLElBQUksQ0FBQ3VCLEtBQUssQ0FBQ3BCLFNBQVMsRUFBRTtZQUVqRSxNQUFNeUIsTUFBTUQsS0FBS0MsR0FBRztZQUNwQixNQUFNa0MsWUFBWWxDLE1BQU0sSUFBSSxDQUFDQyxjQUFjO1lBQzNDLElBQUksQ0FBQ0EsY0FBYyxHQUFHRDtZQUV0QixJQUFJa0MsWUFBWSxPQUFPLElBQUksQ0FBQ0QsZ0JBQWdCLEVBQUU7WUFFOUMsSUFBSSxDQUFDdEMsS0FBSyxDQUFDbkIsT0FBTyxHQUFHd0IsTUFBTSxJQUFJLENBQUNMLEtBQUssQ0FBQ3BCLFNBQVM7WUFDL0MsSUFBSSxDQUFDb0IsS0FBSyxDQUFDdEIsVUFBVSxHQUFHLElBQUksQ0FBQ21CLG1CQUFtQixDQUFDLElBQUksQ0FBQ0csS0FBSyxDQUFDbkIsT0FBTztZQUVuRSxrQkFBa0I7WUFDbEIsSUFBSSxJQUFJLENBQUNtQixLQUFLLENBQUN0QixVQUFVLElBQUksSUFBSSxDQUFDc0IsS0FBSyxDQUFDckIsVUFBVSxFQUFFO2dCQUNsRCxJQUFJLENBQUMrQixLQUFLO2dCQUNWO1lBQ0Y7YUFFQSxrREFBSSxDQUFDVCxTQUFTLEVBQUNRLFFBQVEsY0FBdkIsOEZBQTBCLElBQUksQ0FBQ1QsS0FBSztZQUNwQ3dDLHNCQUFzQixJQUFJLENBQUNoQyxNQUFNO1FBQ25DO1FBbEVFLElBQUksQ0FBQ1IsS0FBSyxHQUFHLElBQUksQ0FBQ3hCLGVBQWU7UUFDakMsSUFBSSxDQUFDUSxzQkFBc0I7SUFDN0I7QUFxS0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGFsbHktbGFwdG9wL0Rlc2t0b3Avcm9ja2V0Y3Jhc2gvc3JjL2dhbWUvQ3Jhc2hHYW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHNpbXBsZUhhc2ggPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgaGFzaCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaGFyXG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoIC8vIENvbnZlcnQgdG8gMzItYml0IGludGVnZXJcbiAgfVxuICByZXR1cm4gTWF0aC5hYnMoaGFzaCkudG9TdHJpbmcoMTYpXG59XG5cbmV4cG9ydCB0eXBlIEdhbWVQaGFzZSA9ICd3YWl0aW5nJyB8ICdzdGFydGluZycgfCAnaW4tcHJvZ3Jlc3MnIHwgJ2NyYXNoZWQnXG5cbmludGVyZmFjZSBHYW1lU3RhdGUge1xuICBwaGFzZTogR2FtZVBoYXNlXG4gIG11bHRpcGxpZXI6IG51bWJlclxuICBjcmFzaFBvaW50OiBudW1iZXJcbiAgc3RhcnRUaW1lOiBudW1iZXIgfCBudWxsXG4gIGVsYXBzZWQ6IG51bWJlclxuICBoYXNoOiBzdHJpbmdcbiAgc2VlZDogc3RyaW5nXG4gIHByZXZpb3VzR2FtZXM6IEFycmF5PHtcbiAgICBjcmFzaFBvaW50OiBudW1iZXJcbiAgICBoYXNoOiBzdHJpbmdcbiAgICBzZWVkOiBzdHJpbmdcbiAgfT5cbn1cblxuaW50ZXJmYWNlIENyYXNoUG9pbnQge1xuICB2YWx1ZTogbnVtYmVyXG4gIGhhc2g6IHN0cmluZ1xuICBzZWVkOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIENyYXNoR2FtZSB7XG4gIHByaXZhdGUgc3RhdGU6IEdhbWVTdGF0ZVxuICBwcml2YXRlIHJlYWRvbmx5IEhPVVNFX0VER0UgPSAwLjk5IC8vIDElIGhvdXNlIGVkZ2VcbiAgcHJpdmF0ZSByZWFkb25seSBHQU1FX1VQREFURV9SQVRFID0gNjAgLy8gVXBkYXRlcyBwZXIgc2Vjb25kXG4gIHByaXZhdGUgdXBkYXRlSW50ZXJ2YWw6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgbGFzdFVwZGF0ZVRpbWU6IG51bWJlciA9IDBcblxuICBwcml2YXRlIGNhbGxiYWNrczoge1xuICAgIG9uVXBkYXRlPzogKHN0YXRlOiBHYW1lU3RhdGUpID0+IHZvaWRcbiAgICBvbkNyYXNoPzogKGNyYXNoUG9pbnQ6IG51bWJlcikgPT4gdm9pZFxuICAgIG9uU3RhcnRpbmc/OiAoKSA9PiB2b2lkXG4gICAgb25HYW1lU3RhcnQ/OiAoKSA9PiB2b2lkXG4gIH0gPSB7fVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSgpXG4gICAgdGhpcy5nZW5lcmF0ZU5leHRDcmFzaFBvaW50KClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SW5pdGlhbFN0YXRlKCk6IEdhbWVTdGF0ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBoYXNlOiAnd2FpdGluZycsXG4gICAgICBtdWx0aXBsaWVyOiAxLjAwLFxuICAgICAgY3Jhc2hQb2ludDogMS4wMCxcbiAgICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICAgIGVsYXBzZWQ6IDAsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHNlZWQ6ICcnLFxuICAgICAgcHJldmlvdXNHYW1lczogW11cbiAgICB9XG4gIH1cblxuICAvLyBQcm92YWJseSBmYWlyIGNyYXNoIHBvaW50IGdlbmVyYXRpb25cbiAgcHJpdmF0ZSBnZW5lcmF0ZU5leHRDcmFzaFBvaW50KCk6IENyYXNoUG9pbnQge1xuICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzIC0gaW4gcHJvZHVjdGlvbiB0aGlzIHdvdWxkIGNvbWUgZnJvbSBzZXJ2ZXJcbiAgICBjb25zdCBzZXJ2ZXJTZWVkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpXG4gICAgY29uc3QgY2xpZW50U2VlZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKVxuICAgIGNvbnN0IGNvbWJpbmVkU2VlZCA9IGAke3NlcnZlclNlZWR9LSR7Y2xpZW50U2VlZH1gXG4gICAgY29uc3QgaGFzaCA9IHNpbXBsZUhhc2goY29tYmluZWRTZWVkKVxuICAgIFxuICAgIC8vIFVzZSB0aGUgZmlyc3QgOCBjaGFyYWN0ZXJzIG9mIGhhc2ggZm9yIHJhbmRvbW5lc3NcbiAgICBjb25zdCBzZWVkSW50ID0gcGFyc2VJbnQoaGFzaC5zbGljZSgwLCA4KSwgMTYpXG4gICAgY29uc3QgbWF4ID0gMHhmZmZmZmZmZiAvLyAzMi1iaXQgbWF4XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgY3Jhc2ggcG9pbnQgYmV0d2VlbiAxIGFuZCAxMCBmb3IgZGVtb1xuICAgIGNvbnN0IHJhd1BvaW50ID0gKHNlZWRJbnQgJSA5MDApIC8gMTAwICsgMSAvLyAxLjAwIHRvIDEwLjAwXG4gICAgY29uc3QgY3Jhc2hQb2ludCA9IE1hdGgubWF4KDEuMDAsIHJhd1BvaW50ICogdGhpcy5IT1VTRV9FREdFKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBjcmFzaFBvaW50LFxuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIHNlZWQ6IGNvbWJpbmVkU2VlZFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlTXVsdGlwbGllcihlbGFwc2VkOiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIEV4cG9uZW50aWFsIGdyb3d0aCBmdW5jdGlvblxuICAgIC8vIDEuMDY5Nl50IHdoZXJlIHQgaXMgc2Vjb25kcyBlbGFwc2VkXG4gICAgcmV0dXJuIE1hdGgucG93KDEuMDY5NiwgZWxhcHNlZCAvIDEwMDApXG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0ZS5waGFzZSAhPT0gJ2luLXByb2dyZXNzJyB8fCAhdGhpcy5zdGF0ZS5zdGFydFRpbWUpIHJldHVyblxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGRlbHRhVGltZSA9IG5vdyAtIHRoaXMubGFzdFVwZGF0ZVRpbWVcbiAgICB0aGlzLmxhc3RVcGRhdGVUaW1lID0gbm93XG5cbiAgICBpZiAoZGVsdGFUaW1lIDwgMTAwMCAvIHRoaXMuR0FNRV9VUERBVEVfUkFURSkgcmV0dXJuXG5cbiAgICB0aGlzLnN0YXRlLmVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXRlLnN0YXJ0VGltZVxuICAgIHRoaXMuc3RhdGUubXVsdGlwbGllciA9IHRoaXMuY2FsY3VsYXRlTXVsdGlwbGllcih0aGlzLnN0YXRlLmVsYXBzZWQpXG5cbiAgICAvLyBDaGVjayBmb3IgY3Jhc2hcbiAgICBpZiAodGhpcy5zdGF0ZS5tdWx0aXBsaWVyID49IHRoaXMuc3RhdGUuY3Jhc2hQb2ludCkge1xuICAgICAgdGhpcy5jcmFzaCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrcy5vblVwZGF0ZT8uKHRoaXMuc3RhdGUpXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKVxuICB9XG5cbiAgcHVibGljIHN0YXJ0R2FtZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5waGFzZSAhPT0gJ3dhaXRpbmcnKSByZXR1cm5cblxuICAgIC8vIFN0YXJ0IGNvdW50ZG93biBwaGFzZVxuICAgIHRoaXMuc3RhdGUucGhhc2UgPSAnc3RhcnRpbmcnXG4gICAgdGhpcy5jYWxsYmFja3Mub25TdGFydGluZz8uKClcbiAgICBcbiAgICAvLyAzIHNlY29uZCBjb3VudGRvd25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucGhhc2UgPSAnaW4tcHJvZ3Jlc3MnXG4gICAgICB0aGlzLnN0YXRlLnN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSB0aGlzLnN0YXRlLnN0YXJ0VGltZVxuICAgICAgdGhpcy5jYWxsYmFja3Mub25HYW1lU3RhcnQ/LigpXG4gICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfSwgMzAwMClcblxuICAgIHRoaXMuY2FsbGJhY2tzLm9uVXBkYXRlPy4odGhpcy5zdGF0ZSlcbiAgfVxuXG4gIHByaXZhdGUgY3Jhc2goKSB7XG4gICAgLy8gU3RvcCB1cGRhdGVzXG4gICAgaWYgKHRoaXMudXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy51cGRhdGVJbnRlcnZhbClcbiAgICAgIHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5waGFzZSA9ICdjcmFzaGVkJ1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uQ3Jhc2g/Lih0aGlzLnN0YXRlLmNyYXNoUG9pbnQpXG4gICAgXG4gICAgLy8gU3RvcmUgZ2FtZSBoaXN0b3J5XG4gICAgdGhpcy5zdGF0ZS5wcmV2aW91c0dhbWVzLnVuc2hpZnQoe1xuICAgICAgY3Jhc2hQb2ludDogdGhpcy5zdGF0ZS5jcmFzaFBvaW50LFxuICAgICAgaGFzaDogdGhpcy5zdGF0ZS5oYXNoLFxuICAgICAgc2VlZDogdGhpcy5zdGF0ZS5zZWVkXG4gICAgfSlcbiAgICBcbiAgICAvLyBLZWVwIGxhc3QgNTAgZ2FtZXNcbiAgICBpZiAodGhpcy5zdGF0ZS5wcmV2aW91c0dhbWVzLmxlbmd0aCA+IDUwKSB7XG4gICAgICB0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXMucG9wKClcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBuZXh0IGNyYXNoIHBvaW50XG4gICAgY29uc3QgbmV4dENyYXNoID0gdGhpcy5nZW5lcmF0ZU5leHRDcmFzaFBvaW50KClcbiAgICBcbiAgICAvLyBSZXNldCBmb3IgbmV4dCByb3VuZCBhZnRlciBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRJbml0aWFsU3RhdGUoKSxcbiAgICAgICAgY3Jhc2hQb2ludDogbmV4dENyYXNoLnZhbHVlLFxuICAgICAgICBoYXNoOiBuZXh0Q3Jhc2guaGFzaCxcbiAgICAgICAgc2VlZDogbmV4dENyYXNoLnNlZWQsXG4gICAgICAgIHByZXZpb3VzR2FtZXM6IHRoaXMuc3RhdGUucHJldmlvdXNHYW1lc1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsYmFja3Mub25VcGRhdGU/Lih0aGlzLnN0YXRlKVxuICAgIH0sIDIwMDApXG4gIH1cblxuICBwdWJsaWMgdmVyaWZ5R2FtZVJlc3VsdChoYXNoOiBzdHJpbmcsIHNlZWQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgdmVyaWZpY2F0aW9uSGFzaCA9IHNpbXBsZUhhc2goc2VlZClcbiAgICBpZiAodmVyaWZpY2F0aW9uSGFzaCAhPT0gaGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdhbWUgcmVzdWx0JylcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VlZEludCA9IHBhcnNlSW50KGhhc2guc2xpY2UoMCwgOCksIDE2KVxuICAgIGNvbnN0IG1heCA9IDB4ZmZmZmZmZmZcbiAgICBjb25zdCByYXdQb2ludCA9IChzZWVkSW50ICUgOTAwKSAvIDEwMCArIDFcbiAgICByZXR1cm4gTWF0aC5tYXgoMS4wMCwgcmF3UG9pbnQgKiB0aGlzLkhPVVNFX0VER0UpXG4gIH1cblxuICBwdWJsaWMgZ2V0R2FtZVN0YXRzKCkge1xuICAgIGNvbnN0IGdhbWVzID0gdGhpcy5zdGF0ZS5wcmV2aW91c0dhbWVzXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsR2FtZXM6IGdhbWVzLmxlbmd0aCxcbiAgICAgIGF2ZXJhZ2VNdWx0aXBsaWVyOiBnYW1lcy5yZWR1Y2UoKGFjYywgZ2FtZSkgPT4gYWNjICsgZ2FtZS5jcmFzaFBvaW50LCAwKSAvIGdhbWVzLmxlbmd0aCxcbiAgICAgIG1heE11bHRpcGxpZXI6IE1hdGgubWF4KC4uLmdhbWVzLm1hcChnYW1lID0+IGdhbWUuY3Jhc2hQb2ludCkpLFxuICAgICAgbWluTXVsdGlwbGllcjogTWF0aC5taW4oLi4uZ2FtZXMubWFwKGdhbWUgPT4gZ2FtZS5jcmFzaFBvaW50KSksXG4gICAgICBiZWxvdzJ4OiBnYW1lcy5maWx0ZXIoZ2FtZSA9PiBnYW1lLmNyYXNoUG9pbnQgPCAyKS5sZW5ndGgsXG4gICAgICBhYm92ZTEweDogZ2FtZXMuZmlsdGVyKGdhbWUgPT4gZ2FtZS5jcmFzaFBvaW50ID4gMTApLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdWJzY3JpYmUoY2FsbGJhY2tzOiB7XG4gICAgb25VcGRhdGU/OiAoc3RhdGU6IEdhbWVTdGF0ZSkgPT4gdm9pZFxuICAgIG9uQ3Jhc2g/OiAoY3Jhc2hQb2ludDogbnVtYmVyKSA9PiB2b2lkXG4gICAgb25TdGFydGluZz86ICgpID0+IHZvaWRcbiAgICBvbkdhbWVTdGFydD86ICgpID0+IHZvaWRcbiAgfSkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzXG4gIH1cblxuICBwdWJsaWMgZ2V0U3RhdGUoKTogR2FtZVN0YXRlIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnN0YXRlIH1cbiAgfVxuXG4gIHB1YmxpYyBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudXBkYXRlSW50ZXJ2YWwpXG4gICAgfVxuICB9XG59ICJdLCJuYW1lcyI6WyJzaW1wbGVIYXNoIiwic3RyIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJhYnMiLCJ0b1N0cmluZyIsIkNyYXNoR2FtZSIsImdldEluaXRpYWxTdGF0ZSIsInBoYXNlIiwibXVsdGlwbGllciIsImNyYXNoUG9pbnQiLCJzdGFydFRpbWUiLCJlbGFwc2VkIiwic2VlZCIsInByZXZpb3VzR2FtZXMiLCJnZW5lcmF0ZU5leHRDcmFzaFBvaW50Iiwic2VydmVyU2VlZCIsInJhbmRvbSIsInN1YnN0cmluZyIsImNsaWVudFNlZWQiLCJjb21iaW5lZFNlZWQiLCJzZWVkSW50IiwicGFyc2VJbnQiLCJzbGljZSIsIm1heCIsInJhd1BvaW50IiwiSE9VU0VfRURHRSIsInZhbHVlIiwiY2FsY3VsYXRlTXVsdGlwbGllciIsInBvdyIsInN0YXJ0R2FtZSIsInN0YXRlIiwiY2FsbGJhY2tzIiwib25TdGFydGluZyIsInNldFRpbWVvdXQiLCJEYXRlIiwibm93IiwibGFzdFVwZGF0ZVRpbWUiLCJvbkdhbWVTdGFydCIsInVwZGF0ZSIsIm9uVXBkYXRlIiwiY3Jhc2giLCJ1cGRhdGVJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvbkNyYXNoIiwidW5zaGlmdCIsInBvcCIsIm5leHRDcmFzaCIsInZlcmlmeUdhbWVSZXN1bHQiLCJ2ZXJpZmljYXRpb25IYXNoIiwiRXJyb3IiLCJnZXRHYW1lU3RhdHMiLCJnYW1lcyIsInRvdGFsR2FtZXMiLCJhdmVyYWdlTXVsdGlwbGllciIsInJlZHVjZSIsImFjYyIsImdhbWUiLCJtYXhNdWx0aXBsaWVyIiwibWFwIiwibWluTXVsdGlwbGllciIsIm1pbiIsImJlbG93MngiLCJmaWx0ZXIiLCJhYm92ZTEweCIsInN1YnNjcmliZSIsImdldFN0YXRlIiwiY2xlYW51cCIsImNvbnN0cnVjdG9yIiwiR0FNRV9VUERBVEVfUkFURSIsImRlbHRhVGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/game/CrashGame.ts\n"));

/***/ })

});