"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/contexts/GameContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/GameContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameProvider: () => (/* binding */ GameProvider),\n/* harmony export */   useGame: () => (/* binding */ useGame)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _game_CrashGame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/game/CrashGame */ \"(app-pages-browser)/./src/game/CrashGame.ts\");\n/* __next_internal_client_entry_do_not_use__ GameProvider,useGame auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst GameContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst GameProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const gameInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [gameState, setGameState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"GameProvider.useState\": ()=>{\n            if (!gameInstanceRef.current) {\n                gameInstanceRef.current = new _game_CrashGame__WEBPACK_IMPORTED_MODULE_2__.CrashGame();\n            }\n            return gameInstanceRef.current.getState();\n        }\n    }[\"GameProvider.useState\"]);\n    const [bets, setBets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"GameProvider.useEffect\": ()=>{\n            const game = gameInstanceRef.current;\n            if (!game) return;\n            game.subscribe({\n                onUpdate: {\n                    \"GameProvider.useEffect\": (state)=>setGameState(state)\n                }[\"GameProvider.useEffect\"],\n                onCrash: {\n                    \"GameProvider.useEffect\": (crashPoint)=>{\n                        // Handle bets resolution\n                        setBets({\n                            \"GameProvider.useEffect\": (currentBets)=>currentBets.map({\n                                    \"GameProvider.useEffect\": (bet)=>{\n                                        if (bet.cashedOut) return bet;\n                                        return {\n                                            ...bet,\n                                            cashedOut: false,\n                                            profit: -bet.amount\n                                        };\n                                    }\n                                }[\"GameProvider.useEffect\"])\n                        }[\"GameProvider.useEffect\"]);\n                    }\n                }[\"GameProvider.useEffect\"]\n            });\n            return ({\n                \"GameProvider.useEffect\": ()=>{\n                    game.cleanup();\n                }\n            })[\"GameProvider.useEffect\"];\n        }\n    }[\"GameProvider.useEffect\"], []);\n    const placeBet = (amount, autoCashout)=>{\n        if (gameState.phase !== 'waiting') return;\n        setBets((current)=>[\n                ...current,\n                {\n                    id: Date.now(),\n                    username: 'You',\n                    amount,\n                    autoCashout,\n                    cashedOut: false\n                }\n            ]);\n    };\n    const cashout = ()=>{\n        if (gameState.phase !== 'in-progress') return;\n        setBets((current)=>current.map((bet)=>{\n                if (bet.username === 'You' && !bet.cashedOut) {\n                    return {\n                        ...bet,\n                        cashedOut: true,\n                        profit: bet.amount * (gameState.multiplier - 1)\n                    };\n                }\n                return bet;\n            }));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GameContext.Provider, {\n        value: {\n            phase: gameState.phase,\n            multiplier: gameState.multiplier,\n            hash: gameState.hash,\n            previousGames: gameState.previousGames,\n            startGame: ()=>{\n                var _gameInstanceRef_current;\n                return (_gameInstanceRef_current = gameInstanceRef.current) === null || _gameInstanceRef_current === void 0 ? void 0 : _gameInstanceRef_current.startGame();\n            },\n            placeBet,\n            cashout\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/stally-laptop/Desktop/rocketcrash/src/contexts/GameContext.tsx\",\n        lineNumber: 82,\n        columnNumber: 5\n    }, undefined);\n};\n_s(GameProvider, \"fc3dqHWfPezB4J3bbp02V669o+4=\");\n_c = GameProvider;\nconst useGame = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(GameContext);\n    if (!context) throw new Error('useGame must be used within a GameProvider');\n    return context;\n};\n_s1(useGame, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"GameProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9HYW1lQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFcUY7QUFDekM7QUFHNUMsTUFBTU8sNEJBQWNOLG9EQUFhQSxDQUF5QjtBQUVuRCxNQUFNTyxlQUFlO1FBQUMsRUFBRUMsUUFBUSxFQUFpQzs7SUFDdEUsTUFBTUMsa0JBQWtCTiw2Q0FBTUEsQ0FBbUI7SUFDakQsTUFBTSxDQUFDTyxXQUFXQyxhQUFhLEdBQUdQLCtDQUFRQTtpQ0FBWTtZQUNwRCxJQUFJLENBQUNLLGdCQUFnQkcsT0FBTyxFQUFFO2dCQUM1QkgsZ0JBQWdCRyxPQUFPLEdBQUcsSUFBSVAsc0RBQVNBO1lBQ3pDO1lBQ0EsT0FBT0ksZ0JBQWdCRyxPQUFPLENBQUNDLFFBQVE7UUFDekM7O0lBQ0EsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdYLCtDQUFRQSxDQU81QixFQUFFO0lBRU5GLGdEQUFTQTtrQ0FBQztZQUNSLE1BQU1jLE9BQU9QLGdCQUFnQkcsT0FBTztZQUNwQyxJQUFJLENBQUNJLE1BQU07WUFFWEEsS0FBS0MsU0FBUyxDQUFDO2dCQUNiQyxRQUFROzhDQUFFLENBQUNDLFFBQVVSLGFBQWFROztnQkFDbENDLE9BQU87OENBQUUsQ0FBQ0M7d0JBQ1IseUJBQXlCO3dCQUN6Qk47c0RBQVFPLENBQUFBLGNBQ05BLFlBQVlDLEdBQUc7OERBQUNDLENBQUFBO3dDQUNkLElBQUlBLElBQUlDLFNBQVMsRUFBRSxPQUFPRDt3Q0FDMUIsT0FBTzs0Q0FDTCxHQUFHQSxHQUFHOzRDQUNOQyxXQUFXOzRDQUNYQyxRQUFRLENBQUNGLElBQUlHLE1BQU07d0NBQ3JCO29DQUNGOzs7b0JBRUo7O1lBQ0Y7WUFFQTswQ0FBTztvQkFDTFgsS0FBS1ksT0FBTztnQkFDZDs7UUFDRjtpQ0FBRyxFQUFFO0lBRUwsTUFBTUMsV0FBVyxDQUFDRixRQUFnQkc7UUFDaEMsSUFBSXBCLFVBQVVxQixLQUFLLEtBQUssV0FBVztRQUVuQ2hCLFFBQVFILENBQUFBLFVBQVc7bUJBQUlBO2dCQUFTO29CQUM5Qm9CLElBQUlDLEtBQUtDLEdBQUc7b0JBQ1pDLFVBQVU7b0JBQ1ZSO29CQUNBRztvQkFDQUwsV0FBVztnQkFDYjthQUFFO0lBQ0o7SUFFQSxNQUFNVyxVQUFVO1FBQ2QsSUFBSTFCLFVBQVVxQixLQUFLLEtBQUssZUFBZTtRQUV2Q2hCLFFBQVFILENBQUFBLFVBQ05BLFFBQVFXLEdBQUcsQ0FBQ0MsQ0FBQUE7Z0JBQ1YsSUFBSUEsSUFBSVcsUUFBUSxLQUFLLFNBQVMsQ0FBQ1gsSUFBSUMsU0FBUyxFQUFFO29CQUM1QyxPQUFPO3dCQUNMLEdBQUdELEdBQUc7d0JBQ05DLFdBQVc7d0JBQ1hDLFFBQVFGLElBQUlHLE1BQU0sR0FBSWpCLENBQUFBLFVBQVUyQixVQUFVLEdBQUc7b0JBQy9DO2dCQUNGO2dCQUNBLE9BQU9iO1lBQ1Q7SUFFSjtJQUVBLHFCQUNFLDhEQUFDbEIsWUFBWWdDLFFBQVE7UUFBQ0MsT0FBTztZQUMzQlIsT0FBT3JCLFVBQVVxQixLQUFLO1lBQ3RCTSxZQUFZM0IsVUFBVTJCLFVBQVU7WUFDaENHLE1BQU05QixVQUFVOEIsSUFBSTtZQUNwQkMsZUFBZS9CLFVBQVUrQixhQUFhO1lBQ3RDQyxXQUFXO29CQUFNakM7d0JBQUFBLDJCQUFBQSxnQkFBZ0JHLE9BQU8sY0FBdkJILCtDQUFBQSx5QkFBeUJpQyxTQUFTOztZQUNuRGI7WUFDQU87UUFDRjtrQkFDRzVCOzs7Ozs7QUFHUCxFQUFDO0dBckZZRDtLQUFBQTtBQXVGTixNQUFNb0MsVUFBVTs7SUFDckIsTUFBTUMsVUFBVTNDLGlEQUFVQSxDQUFDSztJQUMzQixJQUFJLENBQUNzQyxTQUFTLE1BQU0sSUFBSUMsTUFBTTtJQUM5QixPQUFPRDtBQUNULEVBQUM7SUFKWUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGFsbHktbGFwdG9wL0Rlc2t0b3Avcm9ja2V0Y3Jhc2gvc3JjL2NvbnRleHRzL0dhbWVDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ3Jhc2hHYW1lIH0gZnJvbSAnQC9nYW1lL0NyYXNoR2FtZSdcbmltcG9ydCB7IEdhbWVTdGF0ZSwgR2FtZUNvbnRleHRUeXBlIH0gZnJvbSAnQC90eXBlcy9nYW1lJ1xuXG5jb25zdCBHYW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8R2FtZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbClcblxuZXhwb3J0IGNvbnN0IEdhbWVQcm92aWRlciA9ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiB7XG4gIGNvbnN0IGdhbWVJbnN0YW5jZVJlZiA9IHVzZVJlZjxDcmFzaEdhbWUgfCBudWxsPihudWxsKVxuICBjb25zdCBbZ2FtZVN0YXRlLCBzZXRHYW1lU3RhdGVdID0gdXNlU3RhdGU8R2FtZVN0YXRlPigoKSA9PiB7XG4gICAgaWYgKCFnYW1lSW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgZ2FtZUluc3RhbmNlUmVmLmN1cnJlbnQgPSBuZXcgQ3Jhc2hHYW1lKClcbiAgICB9XG4gICAgcmV0dXJuIGdhbWVJbnN0YW5jZVJlZi5jdXJyZW50LmdldFN0YXRlKClcbiAgfSlcbiAgY29uc3QgW2JldHMsIHNldEJldHNdID0gdXNlU3RhdGU8QXJyYXk8e1xuICAgIGlkOiBudW1iZXJcbiAgICB1c2VybmFtZTogc3RyaW5nXG4gICAgYW1vdW50OiBudW1iZXJcbiAgICBhdXRvQ2FzaG91dD86IG51bWJlclxuICAgIGNhc2hlZE91dD86IGJvb2xlYW5cbiAgICBwcm9maXQ/OiBudW1iZXJcbiAgfT4+KFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZ2FtZSA9IGdhbWVJbnN0YW5jZVJlZi5jdXJyZW50XG4gICAgaWYgKCFnYW1lKSByZXR1cm5cblxuICAgIGdhbWUuc3Vic2NyaWJlKHtcbiAgICAgIG9uVXBkYXRlOiAoc3RhdGUpID0+IHNldEdhbWVTdGF0ZShzdGF0ZSksXG4gICAgICBvbkNyYXNoOiAoY3Jhc2hQb2ludCkgPT4ge1xuICAgICAgICAvLyBIYW5kbGUgYmV0cyByZXNvbHV0aW9uXG4gICAgICAgIHNldEJldHMoY3VycmVudEJldHMgPT4gXG4gICAgICAgICAgY3VycmVudEJldHMubWFwKGJldCA9PiB7XG4gICAgICAgICAgICBpZiAoYmV0LmNhc2hlZE91dCkgcmV0dXJuIGJldFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uYmV0LFxuICAgICAgICAgICAgICBjYXNoZWRPdXQ6IGZhbHNlLFxuICAgICAgICAgICAgICBwcm9maXQ6IC1iZXQuYW1vdW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZ2FtZS5jbGVhbnVwKClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IHBsYWNlQmV0ID0gKGFtb3VudDogbnVtYmVyLCBhdXRvQ2FzaG91dD86IG51bWJlcikgPT4ge1xuICAgIGlmIChnYW1lU3RhdGUucGhhc2UgIT09ICd3YWl0aW5nJykgcmV0dXJuXG5cbiAgICBzZXRCZXRzKGN1cnJlbnQgPT4gWy4uLmN1cnJlbnQsIHtcbiAgICAgIGlkOiBEYXRlLm5vdygpLFxuICAgICAgdXNlcm5hbWU6ICdZb3UnLFxuICAgICAgYW1vdW50LFxuICAgICAgYXV0b0Nhc2hvdXQsXG4gICAgICBjYXNoZWRPdXQ6IGZhbHNlXG4gICAgfV0pXG4gIH1cblxuICBjb25zdCBjYXNob3V0ID0gKCkgPT4ge1xuICAgIGlmIChnYW1lU3RhdGUucGhhc2UgIT09ICdpbi1wcm9ncmVzcycpIHJldHVyblxuXG4gICAgc2V0QmV0cyhjdXJyZW50ID0+XG4gICAgICBjdXJyZW50Lm1hcChiZXQgPT4ge1xuICAgICAgICBpZiAoYmV0LnVzZXJuYW1lID09PSAnWW91JyAmJiAhYmV0LmNhc2hlZE91dCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5iZXQsXG4gICAgICAgICAgICBjYXNoZWRPdXQ6IHRydWUsXG4gICAgICAgICAgICBwcm9maXQ6IGJldC5hbW91bnQgKiAoZ2FtZVN0YXRlLm11bHRpcGxpZXIgLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmV0XG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPEdhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBwaGFzZTogZ2FtZVN0YXRlLnBoYXNlLFxuICAgICAgbXVsdGlwbGllcjogZ2FtZVN0YXRlLm11bHRpcGxpZXIsXG4gICAgICBoYXNoOiBnYW1lU3RhdGUuaGFzaCxcbiAgICAgIHByZXZpb3VzR2FtZXM6IGdhbWVTdGF0ZS5wcmV2aW91c0dhbWVzLFxuICAgICAgc3RhcnRHYW1lOiAoKSA9PiBnYW1lSW5zdGFuY2VSZWYuY3VycmVudD8uc3RhcnRHYW1lKCksXG4gICAgICBwbGFjZUJldCxcbiAgICAgIGNhc2hvdXRcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0dhbWVDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBjb25zdCB1c2VHYW1lID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChHYW1lQ29udGV4dClcbiAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUdhbWUgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEdhbWVQcm92aWRlcicpXG4gIHJldHVybiBjb250ZXh0XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJDcmFzaEdhbWUiLCJHYW1lQ29udGV4dCIsIkdhbWVQcm92aWRlciIsImNoaWxkcmVuIiwiZ2FtZUluc3RhbmNlUmVmIiwiZ2FtZVN0YXRlIiwic2V0R2FtZVN0YXRlIiwiY3VycmVudCIsImdldFN0YXRlIiwiYmV0cyIsInNldEJldHMiLCJnYW1lIiwic3Vic2NyaWJlIiwib25VcGRhdGUiLCJzdGF0ZSIsIm9uQ3Jhc2giLCJjcmFzaFBvaW50IiwiY3VycmVudEJldHMiLCJtYXAiLCJiZXQiLCJjYXNoZWRPdXQiLCJwcm9maXQiLCJhbW91bnQiLCJjbGVhbnVwIiwicGxhY2VCZXQiLCJhdXRvQ2FzaG91dCIsInBoYXNlIiwiaWQiLCJEYXRlIiwibm93IiwidXNlcm5hbWUiLCJjYXNob3V0IiwibXVsdGlwbGllciIsIlByb3ZpZGVyIiwidmFsdWUiLCJoYXNoIiwicHJldmlvdXNHYW1lcyIsInN0YXJ0R2FtZSIsInVzZUdhbWUiLCJjb250ZXh0IiwiRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/GameContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/game/CrashGame.ts":
/*!*******************************!*\
  !*** ./src/game/CrashGame.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrashGame: () => (/* binding */ CrashGame)\n/* harmony export */ });\nconst simpleHash = (str)=>{\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash // Convert to 32-bit integer\n        ;\n    }\n    return Math.abs(hash).toString(16);\n};\nclass CrashGame {\n    getInitialState() {\n        return {\n            phase: 'waiting',\n            multiplier: 1.00,\n            crashPoint: 1.00,\n            startTime: null,\n            elapsed: 0,\n            hash: '',\n            seed: '',\n            previousGames: []\n        };\n    }\n    // Provably fair crash point generation\n    generateNextCrashPoint() {\n        // For demo purposes - in production this would come from server\n        const serverSeed = Math.random().toString(36).substring(2);\n        const clientSeed = Math.random().toString(36).substring(2);\n        const combinedSeed = \"\".concat(serverSeed, \"-\").concat(clientSeed);\n        const hash = simpleHash(combinedSeed);\n        // Use the first 8 characters of hash for randomness\n        const seedInt = parseInt(hash.slice(0, 8), 16);\n        const max = 0xffffffff // 32-bit max\n        ;\n        // Generate crash point between 1 and 10 for demo\n        const rawPoint = seedInt % 900 / 100 + 1 // 1.00 to 10.00\n        ;\n        const crashPoint = Math.max(1.00, rawPoint * this.HOUSE_EDGE);\n        return {\n            value: crashPoint,\n            hash: hash,\n            seed: combinedSeed\n        };\n    }\n    calculateMultiplier(elapsed) {\n        // Exponential growth function\n        // 1.0696^t where t is seconds elapsed\n        return Math.pow(1.0696, elapsed / 1000);\n    }\n    startGame() {\n        var _this_callbacks_onStarting, _this_callbacks, _this_callbacks_onUpdate, _this_callbacks1;\n        if (this.state.phase !== 'waiting') return;\n        this.state.phase = 'starting';\n        (_this_callbacks_onStarting = (_this_callbacks = this.callbacks).onStarting) === null || _this_callbacks_onStarting === void 0 ? void 0 : _this_callbacks_onStarting.call(_this_callbacks);\n        this.startTimeout = window.setTimeout(()=>{\n            var _this_callbacks_onGameStart, _this_callbacks;\n            this.state.phase = 'in-progress';\n            this.state.startTime = Date.now();\n            this.lastUpdateTime = this.state.startTime;\n            (_this_callbacks_onGameStart = (_this_callbacks = this.callbacks).onGameStart) === null || _this_callbacks_onGameStart === void 0 ? void 0 : _this_callbacks_onGameStart.call(_this_callbacks);\n            this.update();\n        }, 3000);\n        (_this_callbacks_onUpdate = (_this_callbacks1 = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks1, this.state);\n    }\n    crash() {\n        var _this_callbacks_onCrash, _this_callbacks;\n        // Stop updates\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n        this.state.phase = 'crashed';\n        (_this_callbacks_onCrash = (_this_callbacks = this.callbacks).onCrash) === null || _this_callbacks_onCrash === void 0 ? void 0 : _this_callbacks_onCrash.call(_this_callbacks, this.state.crashPoint);\n        // Store game history\n        this.state.previousGames.unshift({\n            crashPoint: this.state.crashPoint,\n            hash: this.state.hash,\n            seed: this.state.seed\n        });\n        // Keep last 50 games\n        if (this.state.previousGames.length > 50) {\n            this.state.previousGames.pop();\n        }\n        // Generate next crash point\n        const nextCrash = this.generateNextCrashPoint();\n        // Reset for next round after delay\n        setTimeout(()=>{\n            var _this_callbacks_onUpdate, _this_callbacks;\n            this.state = {\n                ...this.getInitialState(),\n                crashPoint: nextCrash.value,\n                hash: nextCrash.hash,\n                seed: nextCrash.seed,\n                previousGames: this.state.previousGames\n            };\n            (_this_callbacks_onUpdate = (_this_callbacks = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks, this.state);\n        }, 2000);\n    }\n    verifyGameResult(hash, seed) {\n        const verificationHash = simpleHash(seed);\n        if (verificationHash !== hash) {\n            throw new Error('Invalid game result');\n        }\n        const seedInt = parseInt(hash.slice(0, 8), 16);\n        const max = 0xffffffff;\n        const rawPoint = seedInt % 900 / 100 + 1;\n        return Math.max(1.00, rawPoint * this.HOUSE_EDGE);\n    }\n    getGameStats() {\n        const games = this.state.previousGames;\n        return {\n            totalGames: games.length,\n            averageMultiplier: games.reduce((acc, game)=>acc + game.crashPoint, 0) / games.length,\n            maxMultiplier: Math.max(...games.map((game)=>game.crashPoint)),\n            minMultiplier: Math.min(...games.map((game)=>game.crashPoint)),\n            below2x: games.filter((game)=>game.crashPoint < 2).length,\n            above10x: games.filter((game)=>game.crashPoint > 10).length\n        };\n    }\n    subscribe(callbacks) {\n        this.callbacks = callbacks;\n    }\n    getState() {\n        return {\n            ...this.state\n        };\n    }\n    cleanup() {\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n        // Cancel any pending animations\n        if (this.animationFrame) {\n            cancelAnimationFrame(this.animationFrame);\n            this.animationFrame = null;\n        }\n        // Clear any pending timeouts\n        if (this.startTimeout) {\n            clearTimeout(this.startTimeout);\n            this.startTimeout = null;\n        }\n        if (this.crashTimeout) {\n            clearTimeout(this.crashTimeout);\n            this.crashTimeout = null;\n        }\n        // Reset state\n        this.state = this.getInitialState();\n        this.callbacks = {};\n    }\n    constructor(){\n        this.HOUSE_EDGE = 0.99 // 1% house edge\n        ;\n        this.GAME_UPDATE_RATE = 60 // Updates per second\n        ;\n        this.updateInterval = null;\n        this.lastUpdateTime = 0;\n        this.callbacks = {};\n        // Add proper timeout handling\n        this.startTimeout = null;\n        this.crashTimeout = null;\n        this.animationFrame = null;\n        this.update = ()=>{\n            var _this_callbacks_onUpdate, _this_callbacks;\n            if (this.state.phase !== 'in-progress' || !this.state.startTime) return;\n            const now = Date.now();\n            const deltaTime = now - this.lastUpdateTime;\n            this.lastUpdateTime = now;\n            if (deltaTime < 1000 / this.GAME_UPDATE_RATE) return;\n            this.state.elapsed = now - this.state.startTime;\n            this.state.multiplier = this.calculateMultiplier(this.state.elapsed);\n            // Check for crash\n            if (this.state.multiplier >= this.state.crashPoint) {\n                this.crash();\n                return;\n            }\n            (_this_callbacks_onUpdate = (_this_callbacks = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks, this.state);\n            this.animationFrame = requestAnimationFrame(this.update);\n        };\n        this.state = this.getInitialState();\n        this.generateNextCrashPoint();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9nYW1lL0NyYXNoR2FtZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsYUFBYSxDQUFDQztJQUNsQixJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLElBQUlHLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxPQUFPSixJQUFJSyxVQUFVLENBQUNIO1FBQzVCRCxPQUFPLENBQUVBLFFBQVEsS0FBS0EsT0FBUUc7UUFDOUJILE9BQU9BLE9BQU9BLEtBQUssNEJBQTRCOztJQUNqRDtJQUNBLE9BQU9LLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTU8sUUFBUSxDQUFDO0FBQ2pDO0FBRU8sTUFBTUM7SUF3QkhDLGtCQUE2QjtRQUNuQyxPQUFPO1lBQ0xDLE9BQU87WUFDUEMsWUFBWTtZQUNaQyxZQUFZO1lBQ1pDLFdBQVc7WUFDWEMsU0FBUztZQUNUZCxNQUFNO1lBQ05lLE1BQU07WUFDTkMsZUFBZSxFQUFFO1FBQ25CO0lBQ0Y7SUFFQSx1Q0FBdUM7SUFDL0JDLHlCQUFxQztRQUMzQyxnRUFBZ0U7UUFDaEUsTUFBTUMsYUFBYWIsS0FBS2MsTUFBTSxHQUFHWixRQUFRLENBQUMsSUFBSWEsU0FBUyxDQUFDO1FBQ3hELE1BQU1DLGFBQWFoQixLQUFLYyxNQUFNLEdBQUdaLFFBQVEsQ0FBQyxJQUFJYSxTQUFTLENBQUM7UUFDeEQsTUFBTUUsZUFBZSxHQUFpQkQsT0FBZEgsWUFBVyxLQUFjLE9BQVhHO1FBQ3RDLE1BQU1yQixPQUFPRixXQUFXd0I7UUFFeEIsb0RBQW9EO1FBQ3BELE1BQU1DLFVBQVVDLFNBQVN4QixLQUFLeUIsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUMzQyxNQUFNQyxNQUFNLFdBQVcsYUFBYTs7UUFFcEMsaURBQWlEO1FBQ2pELE1BQU1DLFdBQVcsVUFBVyxNQUFPLE1BQU0sRUFBRSxnQkFBZ0I7O1FBQzNELE1BQU1mLGFBQWFQLEtBQUtxQixHQUFHLENBQUMsTUFBTUMs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QUN0QixVQUFVLElBQUksSUFBSSxDQUFDc0IsS0FBSyxDQUFDckIsVUFBVSxFQUFFO2dCQUNsRCxJQUFJLENBQUNpQyxLQUFLO2dCQUNWO1lBQ0Y7YUFFQSxrREFBSSxDQUFDWCxTQUFTLEVBQUNVLFFBQVEsY0FBdkIsOEZBQTBCLElBQUksQ0FBQ1gsS0FBSztZQUNwQyxJQUFJLENBQUN1QyxjQUFjLEdBQUdPLHNCQUFzQixJQUFJLENBQUNwQyxNQUFNO1FBQ3pEO1FBbEVFLElBQUksQ0FBQ1YsS0FBSyxHQUFHLElBQUksQ0FBQ3hCLGVBQWU7UUFDakMsSUFBSSxDQUFDUSxzQkFBc0I7SUFDN0I7QUF5TEYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGFsbHktbGFwdG9wL0Rlc2t0b3Avcm9ja2V0Y3Jhc2gvc3JjL2dhbWUvQ3Jhc2hHYW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdhbWVQaGFzZSwgR2FtZVN0YXRlIH0gZnJvbSAnQC90eXBlcy9nYW1lJ1xuXG5jb25zdCBzaW1wbGVIYXNoID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgbGV0IGhhc2ggPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhclxuICAgIGhhc2ggPSBoYXNoICYgaGFzaCAvLyBDb252ZXJ0IHRvIDMyLWJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKGhhc2gpLnRvU3RyaW5nKDE2KVxufVxuXG5leHBvcnQgY2xhc3MgQ3Jhc2hHYW1lIHtcbiAgcHJpdmF0ZSBzdGF0ZTogR2FtZVN0YXRlXG4gIHByaXZhdGUgcmVhZG9ubHkgSE9VU0VfRURHRSA9IDAuOTkgLy8gMSUgaG91c2UgZWRnZVxuICBwcml2YXRlIHJlYWRvbmx5IEdBTUVfVVBEQVRFX1JBVEUgPSA2MCAvLyBVcGRhdGVzIHBlciBzZWNvbmRcbiAgcHJpdmF0ZSB1cGRhdGVJbnRlcnZhbDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZTogbnVtYmVyID0gMFxuXG4gIHByaXZhdGUgY2FsbGJhY2tzOiB7XG4gICAgb25VcGRhdGU/OiAoc3RhdGU6IEdhbWVTdGF0ZSkgPT4gdm9pZFxuICAgIG9uQ3Jhc2g/OiAoY3Jhc2hQb2ludDogbnVtYmVyKSA9PiB2b2lkXG4gICAgb25TdGFydGluZz86ICgpID0+IHZvaWRcbiAgICBvbkdhbWVTdGFydD86ICgpID0+IHZvaWRcbiAgfSA9IHt9XG5cbiAgLy8gQWRkIHByb3BlciB0aW1lb3V0IGhhbmRsaW5nXG4gIHByaXZhdGUgc3RhcnRUaW1lb3V0OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGNyYXNoVGltZW91dDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBhbmltYXRpb25GcmFtZTogbnVtYmVyIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKVxuICAgIHRoaXMuZ2VuZXJhdGVOZXh0Q3Jhc2hQb2ludCgpXG4gIH1cblxuICBwcml2YXRlIGdldEluaXRpYWxTdGF0ZSgpOiBHYW1lU3RhdGUge1xuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogJ3dhaXRpbmcnLFxuICAgICAgbXVsdGlwbGllcjogMS4wMCxcbiAgICAgIGNyYXNoUG9pbnQ6IDEuMDAsXG4gICAgICBzdGFydFRpbWU6IG51bGwsXG4gICAgICBlbGFwc2VkOiAwLFxuICAgICAgaGFzaDogJycsXG4gICAgICBzZWVkOiAnJyxcbiAgICAgIHByZXZpb3VzR2FtZXM6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gUHJvdmFibHkgZmFpciBjcmFzaCBwb2ludCBnZW5lcmF0aW9uXG4gIHByaXZhdGUgZ2VuZXJhdGVOZXh0Q3Jhc2hQb2ludCgpOiBDcmFzaFBvaW50IHtcbiAgICAvLyBGb3IgZGVtbyBwdXJwb3NlcyAtIGluIHByb2R1Y3Rpb24gdGhpcyB3b3VsZCBjb21lIGZyb20gc2VydmVyXG4gICAgY29uc3Qgc2VydmVyU2VlZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKVxuICAgIGNvbnN0IGNsaWVudFNlZWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMilcbiAgICBjb25zdCBjb21iaW5lZFNlZWQgPSBgJHtzZXJ2ZXJTZWVkfS0ke2NsaWVudFNlZWR9YFxuICAgIGNvbnN0IGhhc2ggPSBzaW1wbGVIYXNoKGNvbWJpbmVkU2VlZClcbiAgICBcbiAgICAvLyBVc2UgdGhlIGZpcnN0IDggY2hhcmFjdGVycyBvZiBoYXNoIGZvciByYW5kb21uZXNzXG4gICAgY29uc3Qgc2VlZEludCA9IHBhcnNlSW50KGhhc2guc2xpY2UoMCwgOCksIDE2KVxuICAgIGNvbnN0IG1heCA9IDB4ZmZmZmZmZmYgLy8gMzItYml0IG1heFxuICAgIFxuICAgIC8vIEdlbmVyYXRlIGNyYXNoIHBvaW50IGJldHdlZW4gMSBhbmQgMTAgZm9yIGRlbW9cbiAgICBjb25zdCByYXdQb2ludCA9IChzZWVkSW50ICUgOTAwKSAvIDEwMCArIDEgLy8gMS4wMCB0byAxMC4wMFxuICAgIGNvbnN0IGNyYXNoUG9pbnQgPSBNYXRoLm1heCgxLjAwLCByYXdQb2ludCAqIHRoaXMuSE9VU0VfRURHRSlcblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogY3Jhc2hQb2ludCxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzZWVkOiBjb21iaW5lZFNlZWRcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU11bHRpcGxpZXIoZWxhcHNlZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyBFeHBvbmVudGlhbCBncm93dGggZnVuY3Rpb25cbiAgICAvLyAxLjA2OTZedCB3aGVyZSB0IGlzIHNlY29uZHMgZWxhcHNlZFxuICAgIHJldHVybiBNYXRoLnBvdygxLjA2OTYsIGVsYXBzZWQgLyAxMDAwKVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuc3RhdGUucGhhc2UgIT09ICdpbi1wcm9ncmVzcycgfHwgIXRoaXMuc3RhdGUuc3RhcnRUaW1lKSByZXR1cm5cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSB0aGlzLmxhc3RVcGRhdGVUaW1lXG4gICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IG5vd1xuXG4gICAgaWYgKGRlbHRhVGltZSA8IDEwMDAgLyB0aGlzLkdBTUVfVVBEQVRFX1JBVEUpIHJldHVyblxuXG4gICAgdGhpcy5zdGF0ZS5lbGFwc2VkID0gbm93IC0gdGhpcy5zdGF0ZS5zdGFydFRpbWVcbiAgICB0aGlzLnN0YXRlLm11bHRpcGxpZXIgPSB0aGlzLmNhbGN1bGF0ZU11bHRpcGxpZXIodGhpcy5zdGF0ZS5lbGFwc2VkKVxuXG4gICAgLy8gQ2hlY2sgZm9yIGNyYXNoXG4gICAgaWYgKHRoaXMuc3RhdGUubXVsdGlwbGllciA+PSB0aGlzLnN0YXRlLmNyYXNoUG9pbnQpIHtcbiAgICAgIHRoaXMuY3Jhc2goKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFja3Mub25VcGRhdGU/Lih0aGlzLnN0YXRlKVxuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUpXG4gIH1cblxuICBwdWJsaWMgc3RhcnRHYW1lKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBoYXNlICE9PSAnd2FpdGluZycpIHJldHVyblxuXG4gICAgdGhpcy5zdGF0ZS5waGFzZSA9ICdzdGFydGluZydcbiAgICB0aGlzLmNhbGxiYWNrcy5vblN0YXJ0aW5nPy4oKVxuICAgIFxuICAgIHRoaXMuc3RhcnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5waGFzZSA9ICdpbi1wcm9ncmVzcydcbiAgICAgIHRoaXMuc3RhdGUuc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IHRoaXMuc3RhdGUuc3RhcnRUaW1lXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkdhbWVTdGFydD8uKClcbiAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9LCAzMDAwKVxuXG4gICAgdGhpcy5jYWxsYmFja3Mub25VcGRhdGU/Lih0aGlzLnN0YXRlKVxuICB9XG5cbiAgcHJpdmF0ZSBjcmFzaCgpIHtcbiAgICAvLyBTdG9wIHVwZGF0ZXNcbiAgICBpZiAodGhpcy51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnVwZGF0ZUludGVydmFsKVxuICAgICAgdGhpcy51cGRhdGVJbnRlcnZhbCA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnBoYXNlID0gJ2NyYXNoZWQnXG4gICAgdGhpcy5jYWxsYmFja3Mub25DcmFzaD8uKHRoaXMuc3RhdGUuY3Jhc2hQb2ludClcbiAgICBcbiAgICAvLyBTdG9yZSBnYW1lIGhpc3RvcnlcbiAgICB0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXMudW5zaGlmdCh7XG4gICAgICBjcmFzaFBvaW50OiB0aGlzLnN0YXRlLmNyYXNoUG9pbnQsXG4gICAgICBoYXNoOiB0aGlzLnN0YXRlLmhhc2gsXG4gICAgICBzZWVkOiB0aGlzLnN0YXRlLnNlZWRcbiAgICB9KVxuICAgIFxuICAgIC8vIEtlZXAgbGFzdCA1MCBnYW1lc1xuICAgIGlmICh0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXMubGVuZ3RoID4gNTApIHtcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNHYW1lcy5wb3AoKVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIG5leHQgY3Jhc2ggcG9pbnRcbiAgICBjb25zdCBuZXh0Q3Jhc2ggPSB0aGlzLmdlbmVyYXRlTmV4dENyYXNoUG9pbnQoKVxuICAgIFxuICAgIC8vIFJlc2V0IGZvciBuZXh0IHJvdW5kIGFmdGVyIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLmdldEluaXRpYWxTdGF0ZSgpLFxuICAgICAgICBjcmFzaFBvaW50OiBuZXh0Q3Jhc2gudmFsdWUsXG4gICAgICAgIGhhc2g6IG5leHRDcmFzaC5oYXNoLFxuICAgICAgICBzZWVkOiBuZXh0Q3Jhc2guc2VlZCxcbiAgICAgICAgcHJldmlvdXNHYW1lczogdGhpcy5zdGF0ZS5wcmV2aW91c0dhbWVzXG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vblVwZGF0ZT8uKHRoaXMuc3RhdGUpXG4gICAgfSwgMjAwMClcbiAgfVxuXG4gIHB1YmxpYyB2ZXJpZnlHYW1lUmVzdWx0KGhhc2g6IHN0cmluZywgc2VlZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCB2ZXJpZmljYXRpb25IYXNoID0gc2ltcGxlSGFzaChzZWVkKVxuICAgIGlmICh2ZXJpZmljYXRpb25IYXNoICE9PSBoYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2FtZSByZXN1bHQnKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZWVkSW50ID0gcGFyc2VJbnQoaGFzaC5zbGljZSgwLCA4KSwgMTYpXG4gICAgY29uc3QgbWF4ID0gMHhmZmZmZmZmZlxuICAgIGNvbnN0IHJhd1BvaW50ID0gKHNlZWRJbnQgJSA5MDApIC8gMTAwICsgMVxuICAgIHJldHVybiBNYXRoLm1heCgxLjAwLCByYXdQb2ludCAqIHRoaXMuSE9VU0VfRURHRSlcbiAgfVxuXG4gIHB1YmxpYyBnZXRHYW1lU3RhdHMoKSB7XG4gICAgY29uc3QgZ2FtZXMgPSB0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXNcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxHYW1lczogZ2FtZXMubGVuZ3RoLFxuICAgICAgYXZlcmFnZU11bHRpcGxpZXI6IGdhbWVzLnJlZHVjZSgoYWNjLCBnYW1lKSA9PiBhY2MgKyBnYW1lLmNyYXNoUG9pbnQsIDApIC8gZ2FtZXMubGVuZ3RoLFxuICAgICAgbWF4TXVsdGlwbGllcjogTWF0aC5tYXgoLi4uZ2FtZXMubWFwKGdhbWUgPT4gZ2FtZS5jcmFzaFBvaW50KSksXG4gICAgICBtaW5NdWx0aXBsaWVyOiBNYXRoLm1pbiguLi5nYW1lcy5tYXAoZ2FtZSA9PiBnYW1lLmNyYXNoUG9pbnQpKSxcbiAgICAgIGJlbG93Mng6IGdhbWVzLmZpbHRlcihnYW1lID0+IGdhbWUuY3Jhc2hQb2ludCA8IDIpLmxlbmd0aCxcbiAgICAgIGFib3ZlMTB4OiBnYW1lcy5maWx0ZXIoZ2FtZSA9PiBnYW1lLmNyYXNoUG9pbnQgPiAxMCkubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN1YnNjcmliZShjYWxsYmFja3M6IHtcbiAgICBvblVwZGF0ZT86IChzdGF0ZTogR2FtZVN0YXRlKSA9PiB2b2lkXG4gICAgb25DcmFzaD86IChjcmFzaFBvaW50OiBudW1iZXIpID0+IHZvaWRcbiAgICBvblN0YXJ0aW5nPzogKCkgPT4gdm9pZFxuICAgIG9uR2FtZVN0YXJ0PzogKCkgPT4gdm9pZFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3NcbiAgfVxuXG4gIHB1YmxpYyBnZXRTdGF0ZSgpOiBHYW1lU3RhdGUge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc3RhdGUgfVxuICB9XG5cbiAgcHVibGljIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy51cGRhdGVJbnRlcnZhbClcbiAgICAgIHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuICAgIFxuICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBhbmltYXRpb25zXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpXG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gbnVsbFxuICAgIH1cblxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIHRpbWVvdXRzXG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGFydFRpbWVvdXQpXG4gICAgICB0aGlzLnN0YXJ0VGltZW91dCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jcmFzaFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNyYXNoVGltZW91dClcbiAgICAgIHRoaXMuY3Jhc2hUaW1lb3V0ID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFJlc2V0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKClcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9XG4gIH1cbn0gIl0sIm5hbWVzIjpbInNpbXBsZUhhc2giLCJzdHIiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXIiLCJjaGFyQ29kZUF0IiwiTWF0aCIsImFicyIsInRvU3RyaW5nIiwiQ3Jhc2hHYW1lIiwiZ2V0SW5pdGlhbFN0YXRlIiwicGhhc2UiLCJtdWx0aXBsaWVyIiwiY3Jhc2hQb2ludCIsInN0YXJ0VGltZSIsImVsYXBzZWQiLCJzZWVkIiwicHJldmlvdXNHYW1lcyIsImdlbmVyYXRlTmV4dENyYXNoUG9pbnQiLCJzZXJ2ZXJTZWVkIiwicmFuZG9tIiwic3Vic3RyaW5nIiwiY2xpZW50U2VlZCIsImNvbWJpbmVkU2VlZCIsInNlZWRJbnQiLCJwYXJzZUludCIsInNsaWNlIiwibWF4IiwicmF3UG9pbnQiLCJIT1VTRV9FREdFIiwidmFsdWUiLCJjYWxjdWxhdGVNdWx0aXBsaWVyIiwicG93Iiwic3RhcnRHYW1lIiwic3RhdGUiLCJjYWxsYmFja3MiLCJvblN0YXJ0aW5nIiwic3RhcnRUaW1lb3V0Iiwid2luZG93Iiwic2V0VGltZW91dCIsIkRhdGUiLCJub3ciLCJsYXN0VXBkYXRlVGltZSIsIm9uR2FtZVN0YXJ0IiwidXBkYXRlIiwib25VcGRhdGUiLCJjcmFzaCIsInVwZGF0ZUludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9uQ3Jhc2giLCJ1bnNoaWZ0IiwicG9wIiwibmV4dENyYXNoIiwidmVyaWZ5R2FtZVJlc3VsdCIsInZlcmlmaWNhdGlvbkhhc2giLCJFcnJvciIsImdldEdhbWVTdGF0cyIsImdhbWVzIiwidG90YWxHYW1lcyIsImF2ZXJhZ2VNdWx0aXBsaWVyIiwicmVkdWNlIiwiYWNjIiwiZ2FtZSIsIm1heE11bHRpcGxpZXIiLCJtYXAiLCJtaW5NdWx0aXBsaWVyIiwibWluIiwiYmVsb3cyeCIsImZpbHRlciIsImFib3ZlMTB4Iiwic3Vic2NyaWJlIiwiZ2V0U3RhdGUiLCJjbGVhbnVwIiwiYW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImNyYXNoVGltZW91dCIsImNvbnN0cnVjdG9yIiwiR0FNRV9VUERBVEVfUkFURSIsImRlbHRhVGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/game/CrashGame.ts\n"));

/***/ })

});