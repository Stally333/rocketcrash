"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/game/CrashGame.ts":
/*!*******************************!*\
  !*** ./src/game/CrashGame.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrashGame: () => (/* binding */ CrashGame)\n/* harmony export */ });\nconst simpleHash = (str)=>{\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash // Convert to 32-bit integer\n        ;\n    }\n    return Math.abs(hash).toString(16);\n};\nclass CrashGame {\n    getInitialState() {\n        return {\n            phase: 'waiting',\n            multiplier: 1.00,\n            crashPoint: 1.00,\n            startTime: null,\n            elapsed: 0,\n            hash: '',\n            seed: '',\n            previousGames: []\n        };\n    }\n    // Provably fair crash point generation\n    generateNextCrashPoint() {\n        // For demo purposes - in production this would come from server\n        const serverSeed = Math.random().toString(36).substring(2);\n        const clientSeed = Math.random().toString(36).substring(2);\n        const combinedSeed = \"\".concat(serverSeed, \"-\").concat(clientSeed);\n        const hash = simpleHash(combinedSeed);\n        // Use the first 8 characters of hash for randomness\n        const seedInt = parseInt(hash.slice(0, 8), 16);\n        const max = 0xffffffff // 32-bit max\n        ;\n        // Generate crash point between 1 and 10 for demo\n        const rawPoint = seedInt % 900 / 100 + 1 // 1.00 to 10.00\n        ;\n        const crashPoint = Math.max(1.00, rawPoint * this.HOUSE_EDGE);\n        return {\n            value: crashPoint,\n            hash: hash,\n            seed: combinedSeed\n        };\n    }\n    calculateMultiplier(elapsed) {\n        // Exponential growth function\n        // 1.0696^t where t is seconds elapsed\n        return Math.pow(1.0696, elapsed / 1000);\n    }\n    startGame() {\n        var _this_callbacks_onStarting, _this_callbacks, _this_callbacks_onUpdate, _this_callbacks1;\n        if (this.state.phase !== 'waiting') return;\n        this.state.phase = 'starting';\n        (_this_callbacks_onStarting = (_this_callbacks = this.callbacks).onStarting) === null || _this_callbacks_onStarting === void 0 ? void 0 : _this_callbacks_onStarting.call(_this_callbacks);\n        (_this_callbacks_onUpdate = (_this_callbacks1 = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks1, this.state);\n        // Start the game after a short delay\n        this.startTimeout = window.setTimeout(()=>{\n            var _this_callbacks_onGameStart, _this_callbacks, _this_callbacks_onUpdate, _this_callbacks1;\n            this.state.phase = 'in-progress';\n            this.state.startTime = Date.now();\n            this.lastUpdateTime = Date.now();\n            (_this_callbacks_onGameStart = (_this_callbacks = this.callbacks).onGameStart) === null || _this_callbacks_onGameStart === void 0 ? void 0 : _this_callbacks_onGameStart.call(_this_callbacks);\n            (_this_callbacks_onUpdate = (_this_callbacks1 = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks1, this.state);\n            // Start the game loop\n            this.update();\n        }, 3000) // 3 second countdown\n        ;\n    }\n    crash() {\n        var _this_callbacks_onCrash, _this_callbacks;\n        // Stop updates\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n        this.state.phase = 'crashed';\n        (_this_callbacks_onCrash = (_this_callbacks = this.callbacks).onCrash) === null || _this_callbacks_onCrash === void 0 ? void 0 : _this_callbacks_onCrash.call(_this_callbacks, this.state.crashPoint);\n        // Store game history\n        this.state.previousGames.unshift({\n            crashPoint: this.state.crashPoint,\n            hash: this.state.hash,\n            seed: this.state.seed\n        });\n        // Keep last 50 games\n        if (this.state.previousGames.length > 50) {\n            this.state.previousGames.pop();\n        }\n        // Generate next crash point\n        const nextCrash = this.generateNextCrashPoint();\n        // Reset for next round after delay\n        setTimeout(()=>{\n            var _this_callbacks_onUpdate, _this_callbacks;\n            this.state = {\n                ...this.getInitialState(),\n                crashPoint: nextCrash.value,\n                hash: nextCrash.hash,\n                seed: nextCrash.seed,\n                previousGames: this.state.previousGames\n            };\n            (_this_callbacks_onUpdate = (_this_callbacks = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks, this.state);\n        }, 2000);\n    }\n    verifyGameResult(hash, seed) {\n        const verificationHash = simpleHash(seed);\n        if (verificationHash !== hash) {\n            throw new Error('Invalid game result');\n        }\n        const seedInt = parseInt(hash.slice(0, 8), 16);\n        const max = 0xffffffff;\n        const rawPoint = seedInt % 900 / 100 + 1;\n        return Math.max(1.00, rawPoint * this.HOUSE_EDGE);\n    }\n    getGameStats() {\n        const games = this.state.previousGames;\n        return {\n            totalGames: games.length,\n            averageMultiplier: games.reduce((acc, game)=>acc + game.crashPoint, 0) / games.length,\n            maxMultiplier: Math.max(...games.map((game)=>game.crashPoint)),\n            minMultiplier: Math.min(...games.map((game)=>game.crashPoint)),\n            below2x: games.filter((game)=>game.crashPoint < 2).length,\n            above10x: games.filter((game)=>game.crashPoint > 10).length\n        };\n    }\n    subscribe(callbacks) {\n        this.callbacks = callbacks;\n    }\n    getState() {\n        return {\n            ...this.state\n        };\n    }\n    cleanup() {\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n        // Cancel any pending animations\n        if (this.animationFrame) {\n            cancelAnimationFrame(this.animationFrame);\n            this.animationFrame = null;\n        }\n        // Clear any pending timeouts\n        if (this.startTimeout) {\n            clearTimeout(this.startTimeout);\n            this.startTimeout = null;\n        }\n        if (this.crashTimeout) {\n            clearTimeout(this.crashTimeout);\n            this.crashTimeout = null;\n        }\n        // Reset state\n        this.state = this.getInitialState();\n        this.callbacks = {};\n    }\n    constructor(){\n        this.HOUSE_EDGE = 0.99 // 1% house edge\n        ;\n        this.GAME_UPDATE_RATE = 60 // Updates per second\n        ;\n        this.updateInterval = null;\n        this.lastUpdateTime = 0;\n        this.callbacks = {};\n        // Add proper timeout handling\n        this.startTimeout = null;\n        this.crashTimeout = null;\n        this.animationFrame = null;\n        this.update = ()=>{\n            var _this_callbacks_onUpdate, _this_callbacks;\n            if (this.state.phase !== 'in-progress' || !this.state.startTime) return;\n            const now = Date.now();\n            const deltaTime = now - this.lastUpdateTime;\n            this.lastUpdateTime = now;\n            // Ensure we're not updating too frequently\n            if (deltaTime < 1000 / this.GAME_UPDATE_RATE) {\n                this.animationFrame = requestAnimationFrame(this.update);\n                return;\n            }\n            this.state.elapsed = now - this.state.startTime;\n            this.state.multiplier = this.calculateMultiplier(this.state.elapsed);\n            // Check for crash\n            if (this.state.multiplier >= this.state.crashPoint) {\n                this.crash();\n                return;\n            }\n            (_this_callbacks_onUpdate = (_this_callbacks = this.callbacks).onUpdate) === null || _this_callbacks_onUpdate === void 0 ? void 0 : _this_callbacks_onUpdate.call(_this_callbacks, this.state);\n            this.animationFrame = requestAnimationFrame(this.update);\n        };\n        this.state = this.getInitialState();\n        this.generateNextCrashPoint();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9nYW1lL0NyYXNoR2FtZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsYUFBYSxDQUFDQztJQUNsQixJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLElBQUlHLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxPQUFPSixJQUFJSyxVQUFVLENBQUNIO1FBQzVCRCxPQUFPLENBQUVBLFFBQVEsS0FBS0EsT0FBUUc7UUFDOUJILE9BQU9BLE9BQU9BLEtBQUssNEJBQTRCOztJQUNqRDtJQUNBLE9BQU9LLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTU8sUUFBUSxDQUFDO0FBQ2pDO0FBRU8sTUFBTUM7SUF3QkhDLGtCQUE2QjtRQUNuQyxPQUFPO1lBQ0xDLE9BQU87WUFDUEMsWUFBWTtZQUNaQyxZQUFZO1lBQ1pDLFdBQVc7WUFDWEMsU0FBUztZQUNUZCxNQUFNO1lBQ05lLE1BQU07WUFDTkMsZUFBZSxFQUFFO1FBQ25CO0lBQ0Y7SUFFQSx1Q0FBdUM7SUFDL0JDLHlCQUFxQztRQUMzQyxnRUFBZ0U7UUFDaEUsTUFBTUMsYUFBYWIsS0FBS2MsTUFBTSxHQUFHWixRQUFRLENBQUMsSUFBSWEsU0FBUyxDQUFDO1FBQ3hELE1BQU1DLGFBQWFoQixLQUFLYyxNQUFNLEdBQUdaLFFBQVEsQ0FBQyxJQUFJYSxTQUFTLENBQUM7UUFDeEQsTUFBTUUsZUFBZSxHQUFpQkQsT0FBZEgsWUFBVyxLQUFjLE9BQVhHO1FBQ3RDLE1BQU1yQixPQUFPRixXQUFXd0I7UUFFeEIsb0RBQW9EO1FBQ3BELE1BQU1DLFVBQVVDLFNBQVN4QixLQUFLeUIsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUMzQyxNQUFNQyxNQUFNLFdBQVcsYUFBYTs7UUFFcEMsaURBQWlEO1FBQ2pELE1BQU1DLFdBQVcsVUFBVyxNQUFPLE1BQU0sRUFBRSxnQkFBZ0I7O1FBQzNELE1BQU1mLGFBQWFQLEtBQUtxQixHQUFHLENBQUMsTUFBTUMs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TUFBTSxJQUFJLENBQUNSLEtBQUssQ0FBQ3BCLFNBQVM7WUFDL0MsSUFBSSxDQUFDb0IsS0FBSyxDQUFDdEIsVUFBVSxHQUFHLElBQUksQ0FBQ21CLG1CQUFtQixDQUFDLElBQUksQ0FBQ0csS0FBSyxDQUFDbkIsT0FBTztZQUVuRSxrQkFBa0I7WUFDbEIsSUFBSSxJQUFJLENBQUNtQixLQUFLLENBQUN0QixVQUFVLElBQUksSUFBSSxDQUFDc0IsS0FBSyxDQUFDckIsVUFBVSxFQUFFO2dCQUNsRCxJQUFJLENBQUNpQyxLQUFLO2dCQUNWO1lBQ0Y7YUFFQSxrREFBSSxDQUFDWCxTQUFTLEVBQUNFLFFBQVEsY0FBdkIsOEZBQTBCLElBQUksQ0FBQ0gsS0FBSztZQUNwQyxJQUFJLENBQUN1QyxjQUFjLEdBQUdPLHNCQUFzQixJQUFJLENBQUNuQyxNQUFNO1FBQ3pEO1FBdEVFLElBQUksQ0FBQ1gsS0FBSyxHQUFHLElBQUksQ0FBQ3hCLGVBQWU7UUFDakMsSUFBSSxDQUFDUSxzQkFBc0I7SUFDN0I7QUFnTUYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGFsbHktbGFwdG9wL0Rlc2t0b3Avcm9ja2V0Y3Jhc2gvc3JjL2dhbWUvQ3Jhc2hHYW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdhbWVQaGFzZSwgR2FtZVN0YXRlLCBDcmFzaFBvaW50IH0gZnJvbSAnQC90eXBlcy9nYW1lJ1xuXG5jb25zdCBzaW1wbGVIYXNoID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgbGV0IGhhc2ggPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhclxuICAgIGhhc2ggPSBoYXNoICYgaGFzaCAvLyBDb252ZXJ0IHRvIDMyLWJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKGhhc2gpLnRvU3RyaW5nKDE2KVxufVxuXG5leHBvcnQgY2xhc3MgQ3Jhc2hHYW1lIHtcbiAgcHJpdmF0ZSBzdGF0ZTogR2FtZVN0YXRlXG4gIHByaXZhdGUgcmVhZG9ubHkgSE9VU0VfRURHRSA9IDAuOTkgLy8gMSUgaG91c2UgZWRnZVxuICBwcml2YXRlIHJlYWRvbmx5IEdBTUVfVVBEQVRFX1JBVEUgPSA2MCAvLyBVcGRhdGVzIHBlciBzZWNvbmRcbiAgcHJpdmF0ZSB1cGRhdGVJbnRlcnZhbDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZTogbnVtYmVyID0gMFxuXG4gIHByaXZhdGUgY2FsbGJhY2tzOiB7XG4gICAgb25VcGRhdGU/OiAoc3RhdGU6IEdhbWVTdGF0ZSkgPT4gdm9pZFxuICAgIG9uQ3Jhc2g/OiAoY3Jhc2hQb2ludDogbnVtYmVyKSA9PiB2b2lkXG4gICAgb25TdGFydGluZz86ICgpID0+IHZvaWRcbiAgICBvbkdhbWVTdGFydD86ICgpID0+IHZvaWRcbiAgfSA9IHt9XG5cbiAgLy8gQWRkIHByb3BlciB0aW1lb3V0IGhhbmRsaW5nXG4gIHByaXZhdGUgc3RhcnRUaW1lb3V0OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGNyYXNoVGltZW91dDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBhbmltYXRpb25GcmFtZTogbnVtYmVyIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKVxuICAgIHRoaXMuZ2VuZXJhdGVOZXh0Q3Jhc2hQb2ludCgpXG4gIH1cblxuICBwcml2YXRlIGdldEluaXRpYWxTdGF0ZSgpOiBHYW1lU3RhdGUge1xuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogJ3dhaXRpbmcnLFxuICAgICAgbXVsdGlwbGllcjogMS4wMCxcbiAgICAgIGNyYXNoUG9pbnQ6IDEuMDAsXG4gICAgICBzdGFydFRpbWU6IG51bGwsXG4gICAgICBlbGFwc2VkOiAwLFxuICAgICAgaGFzaDogJycsXG4gICAgICBzZWVkOiAnJyxcbiAgICAgIHByZXZpb3VzR2FtZXM6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gUHJvdmFibHkgZmFpciBjcmFzaCBwb2ludCBnZW5lcmF0aW9uXG4gIHByaXZhdGUgZ2VuZXJhdGVOZXh0Q3Jhc2hQb2ludCgpOiBDcmFzaFBvaW50IHtcbiAgICAvLyBGb3IgZGVtbyBwdXJwb3NlcyAtIGluIHByb2R1Y3Rpb24gdGhpcyB3b3VsZCBjb21lIGZyb20gc2VydmVyXG4gICAgY29uc3Qgc2VydmVyU2VlZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKVxuICAgIGNvbnN0IGNsaWVudFNlZWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMilcbiAgICBjb25zdCBjb21iaW5lZFNlZWQgPSBgJHtzZXJ2ZXJTZWVkfS0ke2NsaWVudFNlZWR9YFxuICAgIGNvbnN0IGhhc2ggPSBzaW1wbGVIYXNoKGNvbWJpbmVkU2VlZClcbiAgICBcbiAgICAvLyBVc2UgdGhlIGZpcnN0IDggY2hhcmFjdGVycyBvZiBoYXNoIGZvciByYW5kb21uZXNzXG4gICAgY29uc3Qgc2VlZEludCA9IHBhcnNlSW50KGhhc2guc2xpY2UoMCwgOCksIDE2KVxuICAgIGNvbnN0IG1heCA9IDB4ZmZmZmZmZmYgLy8gMzItYml0IG1heFxuICAgIFxuICAgIC8vIEdlbmVyYXRlIGNyYXNoIHBvaW50IGJldHdlZW4gMSBhbmQgMTAgZm9yIGRlbW9cbiAgICBjb25zdCByYXdQb2ludCA9IChzZWVkSW50ICUgOTAwKSAvIDEwMCArIDEgLy8gMS4wMCB0byAxMC4wMFxuICAgIGNvbnN0IGNyYXNoUG9pbnQgPSBNYXRoLm1heCgxLjAwLCByYXdQb2ludCAqIHRoaXMuSE9VU0VfRURHRSlcblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogY3Jhc2hQb2ludCxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzZWVkOiBjb21iaW5lZFNlZWRcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU11bHRpcGxpZXIoZWxhcHNlZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyBFeHBvbmVudGlhbCBncm93dGggZnVuY3Rpb25cbiAgICAvLyAxLjA2OTZedCB3aGVyZSB0IGlzIHNlY29uZHMgZWxhcHNlZFxuICAgIHJldHVybiBNYXRoLnBvdygxLjA2OTYsIGVsYXBzZWQgLyAxMDAwKVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuc3RhdGUucGhhc2UgIT09ICdpbi1wcm9ncmVzcycgfHwgIXRoaXMuc3RhdGUuc3RhcnRUaW1lKSByZXR1cm5cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSB0aGlzLmxhc3RVcGRhdGVUaW1lXG4gICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IG5vd1xuXG4gICAgLy8gRW5zdXJlIHdlJ3JlIG5vdCB1cGRhdGluZyB0b28gZnJlcXVlbnRseVxuICAgIGlmIChkZWx0YVRpbWUgPCAxMDAwIC8gdGhpcy5HQU1FX1VQREFURV9SQVRFKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5lbGFwc2VkID0gbm93IC0gdGhpcy5zdGF0ZS5zdGFydFRpbWVcbiAgICB0aGlzLnN0YXRlLm11bHRpcGxpZXIgPSB0aGlzLmNhbGN1bGF0ZU11bHRpcGxpZXIodGhpcy5zdGF0ZS5lbGFwc2VkKVxuXG4gICAgLy8gQ2hlY2sgZm9yIGNyYXNoXG4gICAgaWYgKHRoaXMuc3RhdGUubXVsdGlwbGllciA+PSB0aGlzLnN0YXRlLmNyYXNoUG9pbnQpIHtcbiAgICAgIHRoaXMuY3Jhc2goKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFja3Mub25VcGRhdGU/Lih0aGlzLnN0YXRlKVxuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUpXG4gIH1cblxuICBwdWJsaWMgc3RhcnRHYW1lKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBoYXNlICE9PSAnd2FpdGluZycpIHJldHVyblxuXG4gICAgdGhpcy5zdGF0ZS5waGFzZSA9ICdzdGFydGluZydcbiAgICB0aGlzLmNhbGxiYWNrcy5vblN0YXJ0aW5nPy4oKVxuICAgIHRoaXMuY2FsbGJhY2tzLm9uVXBkYXRlPy4odGhpcy5zdGF0ZSlcblxuICAgIC8vIFN0YXJ0IHRoZSBnYW1lIGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICB0aGlzLnN0YXJ0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucGhhc2UgPSAnaW4tcHJvZ3Jlc3MnXG4gICAgICB0aGlzLnN0YXRlLnN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkdhbWVTdGFydD8uKClcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uVXBkYXRlPy4odGhpcy5zdGF0ZSlcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgdGhlIGdhbWUgbG9vcFxuICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH0sIDMwMDApIC8vIDMgc2Vjb25kIGNvdW50ZG93blxuICB9XG5cbiAgcHJpdmF0ZSBjcmFzaCgpIHtcbiAgICAvLyBTdG9wIHVwZGF0ZXNcbiAgICBpZiAodGhpcy51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnVwZGF0ZUludGVydmFsKVxuICAgICAgdGhpcy51cGRhdGVJbnRlcnZhbCA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnBoYXNlID0gJ2NyYXNoZWQnXG4gICAgdGhpcy5jYWxsYmFja3Mub25DcmFzaD8uKHRoaXMuc3RhdGUuY3Jhc2hQb2ludClcbiAgICBcbiAgICAvLyBTdG9yZSBnYW1lIGhpc3RvcnlcbiAgICB0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXMudW5zaGlmdCh7XG4gICAgICBjcmFzaFBvaW50OiB0aGlzLnN0YXRlLmNyYXNoUG9pbnQsXG4gICAgICBoYXNoOiB0aGlzLnN0YXRlLmhhc2gsXG4gICAgICBzZWVkOiB0aGlzLnN0YXRlLnNlZWRcbiAgICB9KVxuICAgIFxuICAgIC8vIEtlZXAgbGFzdCA1MCBnYW1lc1xuICAgIGlmICh0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXMubGVuZ3RoID4gNTApIHtcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNHYW1lcy5wb3AoKVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIG5leHQgY3Jhc2ggcG9pbnRcbiAgICBjb25zdCBuZXh0Q3Jhc2ggPSB0aGlzLmdlbmVyYXRlTmV4dENyYXNoUG9pbnQoKVxuICAgIFxuICAgIC8vIFJlc2V0IGZvciBuZXh0IHJvdW5kIGFmdGVyIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLmdldEluaXRpYWxTdGF0ZSgpLFxuICAgICAgICBjcmFzaFBvaW50OiBuZXh0Q3Jhc2gudmFsdWUsXG4gICAgICAgIGhhc2g6IG5leHRDcmFzaC5oYXNoLFxuICAgICAgICBzZWVkOiBuZXh0Q3Jhc2guc2VlZCxcbiAgICAgICAgcHJldmlvdXNHYW1lczogdGhpcy5zdGF0ZS5wcmV2aW91c0dhbWVzXG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vblVwZGF0ZT8uKHRoaXMuc3RhdGUpXG4gICAgfSwgMjAwMClcbiAgfVxuXG4gIHB1YmxpYyB2ZXJpZnlHYW1lUmVzdWx0KGhhc2g6IHN0cmluZywgc2VlZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCB2ZXJpZmljYXRpb25IYXNoID0gc2ltcGxlSGFzaChzZWVkKVxuICAgIGlmICh2ZXJpZmljYXRpb25IYXNoICE9PSBoYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2FtZSByZXN1bHQnKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZWVkSW50ID0gcGFyc2VJbnQoaGFzaC5zbGljZSgwLCA4KSwgMTYpXG4gICAgY29uc3QgbWF4ID0gMHhmZmZmZmZmZlxuICAgIGNvbnN0IHJhd1BvaW50ID0gKHNlZWRJbnQgJSA5MDApIC8gMTAwICsgMVxuICAgIHJldHVybiBNYXRoLm1heCgxLjAwLCByYXdQb2ludCAqIHRoaXMuSE9VU0VfRURHRSlcbiAgfVxuXG4gIHB1YmxpYyBnZXRHYW1lU3RhdHMoKSB7XG4gICAgY29uc3QgZ2FtZXMgPSB0aGlzLnN0YXRlLnByZXZpb3VzR2FtZXNcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxHYW1lczogZ2FtZXMubGVuZ3RoLFxuICAgICAgYXZlcmFnZU11bHRpcGxpZXI6IGdhbWVzLnJlZHVjZSgoYWNjLCBnYW1lKSA9PiBhY2MgKyBnYW1lLmNyYXNoUG9pbnQsIDApIC8gZ2FtZXMubGVuZ3RoLFxuICAgICAgbWF4TXVsdGlwbGllcjogTWF0aC5tYXgoLi4uZ2FtZXMubWFwKGdhbWUgPT4gZ2FtZS5jcmFzaFBvaW50KSksXG4gICAgICBtaW5NdWx0aXBsaWVyOiBNYXRoLm1pbiguLi5nYW1lcy5tYXAoZ2FtZSA9PiBnYW1lLmNyYXNoUG9pbnQpKSxcbiAgICAgIGJlbG93Mng6IGdhbWVzLmZpbHRlcihnYW1lID0+IGdhbWUuY3Jhc2hQb2ludCA8IDIpLmxlbmd0aCxcbiAgICAgIGFib3ZlMTB4OiBnYW1lcy5maWx0ZXIoZ2FtZSA9PiBnYW1lLmNyYXNoUG9pbnQgPiAxMCkubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN1YnNjcmliZShjYWxsYmFja3M6IHtcbiAgICBvblVwZGF0ZT86IChzdGF0ZTogR2FtZVN0YXRlKSA9PiB2b2lkXG4gICAgb25DcmFzaD86IChjcmFzaFBvaW50OiBudW1iZXIpID0+IHZvaWRcbiAgICBvblN0YXJ0aW5nPzogKCkgPT4gdm9pZFxuICAgIG9uR2FtZVN0YXJ0PzogKCkgPT4gdm9pZFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3NcbiAgfVxuXG4gIHB1YmxpYyBnZXRTdGF0ZSgpOiBHYW1lU3RhdGUge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc3RhdGUgfVxuICB9XG5cbiAgcHVibGljIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy51cGRhdGVJbnRlcnZhbClcbiAgICAgIHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuICAgIFxuICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBhbmltYXRpb25zXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpXG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gbnVsbFxuICAgIH1cblxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIHRpbWVvdXRzXG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zdGFydFRpbWVvdXQpXG4gICAgICB0aGlzLnN0YXJ0VGltZW91dCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jcmFzaFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNyYXNoVGltZW91dClcbiAgICAgIHRoaXMuY3Jhc2hUaW1lb3V0ID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFJlc2V0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKClcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9XG4gIH1cbn0gIl0sIm5hbWVzIjpbInNpbXBsZUhhc2giLCJzdHIiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXIiLCJjaGFyQ29kZUF0IiwiTWF0aCIsImFicyIsInRvU3RyaW5nIiwiQ3Jhc2hHYW1lIiwiZ2V0SW5pdGlhbFN0YXRlIiwicGhhc2UiLCJtdWx0aXBsaWVyIiwiY3Jhc2hQb2ludCIsInN0YXJ0VGltZSIsImVsYXBzZWQiLCJzZWVkIiwicHJldmlvdXNHYW1lcyIsImdlbmVyYXRlTmV4dENyYXNoUG9pbnQiLCJzZXJ2ZXJTZWVkIiwicmFuZG9tIiwic3Vic3RyaW5nIiwiY2xpZW50U2VlZCIsImNvbWJpbmVkU2VlZCIsInNlZWRJbnQiLCJwYXJzZUludCIsInNsaWNlIiwibWF4IiwicmF3UG9pbnQiLCJIT1VTRV9FREdFIiwidmFsdWUiLCJjYWxjdWxhdGVNdWx0aXBsaWVyIiwicG93Iiwic3RhcnRHYW1lIiwic3RhdGUiLCJjYWxsYmFja3MiLCJvblN0YXJ0aW5nIiwib25VcGRhdGUiLCJzdGFydFRpbWVvdXQiLCJ3aW5kb3ciLCJzZXRUaW1lb3V0IiwiRGF0ZSIsIm5vdyIsImxhc3RVcGRhdGVUaW1lIiwib25HYW1lU3RhcnQiLCJ1cGRhdGUiLCJjcmFzaCIsInVwZGF0ZUludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9uQ3Jhc2giLCJ1bnNoaWZ0IiwicG9wIiwibmV4dENyYXNoIiwidmVyaWZ5R2FtZVJlc3VsdCIsInZlcmlmaWNhdGlvbkhhc2giLCJFcnJvciIsImdldEdhbWVTdGF0cyIsImdhbWVzIiwidG90YWxHYW1lcyIsImF2ZXJhZ2VNdWx0aXBsaWVyIiwicmVkdWNlIiwiYWNjIiwiZ2FtZSIsIm1heE11bHRpcGxpZXIiLCJtYXAiLCJtaW5NdWx0aXBsaWVyIiwibWluIiwiYmVsb3cyeCIsImZpbHRlciIsImFib3ZlMTB4Iiwic3Vic2NyaWJlIiwiZ2V0U3RhdGUiLCJjbGVhbnVwIiwiYW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImNyYXNoVGltZW91dCIsImNvbnN0cnVjdG9yIiwiR0FNRV9VUERBVEVfUkFURSIsImRlbHRhVGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/game/CrashGame.ts\n"));

/***/ })

});